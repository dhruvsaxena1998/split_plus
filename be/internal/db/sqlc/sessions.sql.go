// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const blacklistToken = `-- name: BlacklistToken :exec
INSERT INTO token_blacklist (token_jti, user_id, expires_at, reason)
VALUES ($1, $2, $3, $4)
`

type BlacklistTokenParams struct {
	TokenJti  string             `json:"token_jti"`
	UserID    pgtype.UUID        `json:"user_id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	Reason    pgtype.Text        `json:"reason"`
}

func (q *Queries) BlacklistToken(ctx context.Context, arg BlacklistTokenParams) error {
	_, err := q.db.Exec(ctx, blacklistToken,
		arg.TokenJti,
		arg.UserID,
		arg.ExpiresAt,
		arg.Reason,
	)
	return err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (user_id, refresh_token_hash, user_agent, ip_address, expires_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, refresh_token_hash, user_agent, ip_address, expires_at, created_at, last_used_at
`

type CreateSessionParams struct {
	UserID           pgtype.UUID        `json:"user_id"`
	RefreshTokenHash string             `json:"refresh_token_hash"`
	UserAgent        pgtype.Text        `json:"user_agent"`
	IpAddress        pgtype.Text        `json:"ip_address"`
	ExpiresAt        pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.UserID,
		arg.RefreshTokenHash,
		arg.UserAgent,
		arg.IpAddress,
		arg.ExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshTokenHash,
		&i.UserAgent,
		&i.IpAddress,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const deleteAllUserSessions = `-- name: DeleteAllUserSessions :exec
DELETE FROM sessions
WHERE user_id = $1
`

func (q *Queries) DeleteAllUserSessions(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllUserSessions, userID)
	return err
}

const deleteExpiredBlacklistedTokens = `-- name: DeleteExpiredBlacklistedTokens :exec
DELETE FROM token_blacklist
WHERE expires_at <= NOW()
`

func (q *Queries) DeleteExpiredBlacklistedTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredBlacklistedTokens)
	return err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM sessions
WHERE expires_at <= NOW()
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredSessions)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions
WHERE refresh_token_hash = $1
`

func (q *Queries) DeleteSession(ctx context.Context, refreshTokenHash string) error {
	_, err := q.db.Exec(ctx, deleteSession, refreshTokenHash)
	return err
}

const getActiveSessionsByUserID = `-- name: GetActiveSessionsByUserID :many
SELECT id, user_id, refresh_token_hash, user_agent, ip_address, expires_at, created_at, last_used_at FROM sessions
WHERE user_id = $1 AND expires_at > NOW()
ORDER BY created_at DESC
`

func (q *Queries) GetActiveSessionsByUserID(ctx context.Context, userID pgtype.UUID) ([]Session, error) {
	rows, err := q.db.Query(ctx, getActiveSessionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RefreshTokenHash,
			&i.UserAgent,
			&i.IpAddress,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByRefreshTokenHash = `-- name: GetSessionByRefreshTokenHash :one
SELECT id, user_id, refresh_token_hash, user_agent, ip_address, expires_at, created_at, last_used_at FROM sessions
WHERE refresh_token_hash = $1 AND expires_at > NOW()
`

func (q *Queries) GetSessionByRefreshTokenHash(ctx context.Context, refreshTokenHash string) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByRefreshTokenHash, refreshTokenHash)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshTokenHash,
		&i.UserAgent,
		&i.IpAddress,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const isTokenBlacklisted = `-- name: IsTokenBlacklisted :one
SELECT EXISTS(
    SELECT 1 FROM token_blacklist
    WHERE token_jti = $1 AND expires_at > NOW()
) AS is_blacklisted
`

func (q *Queries) IsTokenBlacklisted(ctx context.Context, tokenJti string) (bool, error) {
	row := q.db.QueryRow(ctx, isTokenBlacklisted, tokenJti)
	var is_blacklisted bool
	err := row.Scan(&is_blacklisted)
	return is_blacklisted, err
}

const updateSessionLastUsed = `-- name: UpdateSessionLastUsed :exec
UPDATE sessions
SET last_used_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateSessionLastUsed(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateSessionLastUsed, id)
	return err
}
